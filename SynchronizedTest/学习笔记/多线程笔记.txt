1、synchronized 关键字
1）锁的是对象，包含临界资源对象（含this），类对象，其中临界资源对象是指在堆中创建的对象，类对象是方法区的静态资源
2）对锁了同一资源的代码块或者方法，才会进行同步执行，否则互不干扰。
3）锁是针对不同线程的，同一线程（方法调用、类继承等）锁可重入
4）尽量使用同步代码块，避免使用同步方法
5）锁的对象如果被重新赋值，引用指向新的对象，则不改变原本锁的对象，但是指向的新对象加的锁与原有锁不冲突，可并行执行
6）锁的对象如果是常量对象，需要看是否为常量池（字符串），或者栈帧中数值（-127-127），则为同一个对象，如果是new的，必然不是。
7）加锁前，会将工作内存清空，读取主存中的最新数据值，解锁前，会将工作内存中数据同步到主存中，从而保证了数据可见性
8）无公平性，是竞争锁

2、volatile 关键字
1）os操作系统中分硬盘--内存--cpu高速缓存--cpu，其中cpu高速缓存如果在cpu不间断执行（例如执行空while，while如果加了东西就可能不是不间断了，也有可能是）时，
不会清空从内存重新读取，导致内存中改变的变量值cpu无法获取，即线程不可见
2）volatile 告诉os，每次从cpu高速缓存中获取值时，一定要去内存中读取最新值。
3）volatile 不能保证数据的原子性，即当cpu在做数据自增操作时，可能会报中间的某些结果存入内存，然后继续计算，这个时候多个线程能看到这个结果，然后开始自增，
就会导致数据计算结果错误，都从同一个起点开始自增，正确的应该是原子的同一个变量自增才对
4）Atomic 原子性的变量类型，效率比synchronized高，

3、CountDownLatch类
门栓类，new CountDownLatch(5)加五个门栓，cc.countDown();减一个门栓，cc.await();等待知道门栓全部减掉才执行


4、Lock 类（必须手工释放锁标记）
1）	Lock lock =new ReentrantLock();  
lock.lock(); 加锁
lock.unlock();	解锁
lock.tryLock();尝试锁
2）锁的打断
阻塞状态： 包括普通阻塞，等待队列，锁池队列。只有普通阻塞和锁池队列（指ReentrantLock的lockInterruptibly）可以被打断，打断后从阻塞状态唤醒，
抛出异常，然后执行下面的代码逻辑，最后回到原来的锁持有对象，注意打断的时候不能获取到锁标记
3）公平锁
Lock lock =new ReentrantLock(true);
等待时间越长，越先获取到锁标记
4）相对效率比synchronized高，JDK1.7后，两者差距不是很大
5）condition 为Lock增加条件。当条件满足时，做什么事情，如加锁或解锁。如等待或唤醒
Condition newCondition = lock.newCondition();
newCondition.await(); 等待
newCondition.signalAll();唤醒
