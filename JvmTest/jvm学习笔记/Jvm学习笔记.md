# 问题

#### 1、方法区存放的是类信息，静态方法，那么类中的方法存哪里了？

#### 2、栈中会有方法一行行扫描执行，是具体代码还是引用？

#### 3、已解决String
> 对于String的+操作符，分为两种情况，全是常量则拼接后再创建对象，不会创建多个对象
> 对于存在变量时，变量前能拼接多少常量拼接多少常量，然后使用StringBuild创建，append后面所有变量和常量
> 对于new，一定会创建一个新的堆对象
> new在堆中创建的对象拼接部分（即双引号引起部分），会从常量池中拷贝，生成的结果不会放入常量池中


[TOC]





# jvm模块组成

### 1、具有模块

![1553737868176](C:\Users\wangp\AppData\Roaming\Typora\typora-user-images\1553737868176.png)

### 2、类加载子系统

​	``

​		//将类的信息从文件系统或者网络（webSevice 远程读取），加载到方法区，也就是将class字节码文件转换为类对象，存入内存中

​	``

### 3、方法区

``

​	//除了类信息（类对象），还有常量信息，字符串字面值，数字常量值

``

### 4、堆

``

​	//几乎所有的对象实例（除字符常量），new的一定在堆，是所有线程共享

``

1. 堆结构（内存是否连续）

   

2. 对象分代

   - 新生代、老年代、永久代（对HsotSpot而言）

     - 新生态GC回收频率极高，多次（15次）回收后仍未被销毁，则进入老年代
     - 老年代GC回收频率较低
     - 永久代储存类信息和静态属性，也会被回收，1.8之后已被matespace取代

   - 新生代

     - 分为 Eden From To
     - 新创建对象放在Eden(大对象直接进入老年代)，大部分对象在Eden中回收，当new对象时如果Eden空间不足，会触发一次Minor GC，每次GC都会扫描Eden
     - Eden中GC存活的对象放入To，将From存活对象年龄+1或者转移至老年代，再复制到To空间，清空From，然后From  To空间角色置换，From To 在始终会有一个是空的，一个存放所有老年代对象，复制算法，同时保证内存空间连续。
     - 由于To中的对象必然是经过GC后存活的，而From中的还需经过一次鉴别才能知道是否存活，故而采用了这种复制算法。
     - From 也称为S1 To也称为S2

   - 老年代

     - 根据内存容量阈值，可能大的对象会直接进入老年代

   - 永久代

     - 1.7 1.8 开始被mateSpace取代，mateSpace使用元空间，多个项目可以共享同样class，无需指定最大容量为自然内存，或者指定限制也可以。

     - mateSpace提高了GC的性能

     - 不容易指定大小，容易溢出。mateSpace解决了这个问题。

       

### 5、直接内存

``

​	//堆之外相os操作系统申请的一块内存空间，用于NIO库直接使用内存，可理解为buffer所在区域。速度优于堆，适用于读写频繁，如1G数据分10次10M读写，就会放入直接内存中缓存。不受限与堆的最大容量。

``

### 6、垃圾回收系统

``

​	//回收所有能管理的资源，包括堆、方法区、直接内存

​	//并行收集器不是真正的并发，而是有极短暂的停止，并发收集器只有1、3步骤需短暂停止，2、4步骤是真正意义上的并发GC线程

``

> 1. 收集器分类
>
>    - 次收集器
>
>     Scavenge-GC  发生在新生代的收集器，回收速度较快，Eden空间不足时触发。
>
>    - 全收集器
>
>       Full-GC 每次触发Full-GC至少会触发一次Scavenge-GC，效率较慢。老年代空间不足时或显式调用System.gc()触发。
>
>    - 次收集器：serial parnew parallel-Scavenger
>    -  全收集器：serial-Old paramllel-Old CMS
>
>   其他：G1
>
>   需匹配使用
>
> 2. 常见垃圾回收算法
>
>    - 引用计数，引用计数为0则回收，无法处理循环引用。
>
>    - 复制算法，重新压缩整理内存空间，保证内存连续，缺点时需要两倍内存
>
>    - 标记清除，先从根节点开始一层层标记被引用的对象，第二次清除未被标记的对象
>
>    - 标记整理，即标记清除+复制算法，多次标记清除后触发一次标记整理
>
>      > 内存如果不连续，一旦需要存入稍大对象，就有可能因为空间不足而触发GC，甚至GC后空间仍然不足，其实是足够的，只是碎片化了
>
> 3. serial 
>
>    > 串行收集器，单线程收集，暂停所有工作线程，对新生代采用复制算法，对老年代采用标记整理算法
>
> 4. ParNew
>
>    > Serial的多线程版本
>
> 5. Parallel-Scavenge
>
> 更加关注系统吞吐量，适用于科学计算，天文计算
>
>    > 系统吞吐量=运行用户代码时间/（运行用户代买时间+垃圾收集时间）
>
> 6. Serial Old
>
>    > Serial 老年代版
>
> 7. Parallel Old
>
>    > Parallel老年代版
>
> 8. CMS收集器
>
>    > 并发收集器，其实是极其短的停止，获取最短回收停顿时间的并发低暂停收集器
>    >
>    > - 标记过程：初始标记、并发标记，重新标记（并发可能遗漏）
>    > - 并发清除，就地释放，无内存整理
>    > - 缺点：用户线程与标记线程并发时的浮动垃圾，标记清除带来的内存碎片都有可能触发FUll-GC，可设置参数调整
>    >
>    > 
>
> 9. G1收集器
>
>    > 分块管理，新生代、年老代无物理隔离，只是逻辑上的分块，适用于低并发应用

### 7、栈

``

​	//抽象概念，一个线程会创建一个栈帧，多个栈帧组合为java栈，java栈不一定而是尽量是连续的内存空间。

​	//此外，在线程中调用方法会压栈，方法互相调用则不断压栈，方法执行结束弹出（先进后出）。每压一次栈也可以称为栈帧，整体线程是一个栈，多线程组合在一块就是java栈

​	//栈中保存运行时的临时变量，引用信息，方法参数，返回调用，运行的代码信息

``



### 8、本地方法栈

``

​	//调用通常用C语言写的本地方法

``

### 9、PC寄存器

``

​	//与Java栈紧密相关，虚拟机给线程创建栈时会创建一个pc寄存器，它指向栈当前运行方法行数，为了cpu知道线程在哪里继续执行。本地方法是undifined

``



### 10、执行引擎

``

 - //执行虚拟机的字节码，也会有不同的侧重点，如有的是侧重多线程提高并发量，有的是低并发高运算。
 - //从1.4版本后，即时编译(just in time)，在读取时编译为机器码
 - //HotSpot，热点扫描，优先考虑将使用最多的类对象信息存入方法区，较少的类不存，使用时读取。
 - //分java-HotSpot-Client-VM  适用于本地应用开发（eclipse），java-HotSpot-Server-VM 适用于服务器运行（启动慢，执行快,内存占用高），1.6部分及后续版本64位已取消client

``



# Jvm优化



### jvm常用命令

> jps
>
> 显示java进程线程信息 jps -l -v
>
> jstat -参数(gc)  线程id  执行时间（毫秒） 执行次数
>
> jvisualvm
>
> 图形化页面
>
> 

### jvm常见参数

		> 配置方式：java [options] MainClass [arguments]
		> options - JVM 启动参数。 配置多个参数的时候，参数之间使用空格分隔。
		> 参数命名： 常见为 -参数名
		> 参数赋值： 常见为 -参数名=参数值 | -参数名:参数值
		>
		> 

##### 内存设置

具体数据还需压测来验证。

> -Xms:初始堆大小
>
> -Xmx：最大堆大小
>
> -Xmn：设置年轻代大小，一般为整个堆的3/8
>
> -Xss:每个线程的java栈大小，值越小，能生成线程越多。
>
> -XX:NewSize=n:设置年轻代大小
>
> -XX:NewRatio=n:设置年轻代和年老代的比值,如:为 3，表示年轻代与年老代比值为 1：3，
>
> -XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值
>
> -XX:MaxPermSize=n:设置持久代大小
>
> -XX:MaxTenuringThreshold：设置垃圾最大年龄
>
> 调用方式例：
>
> java -Xmx3550m -Xms3550m -Xmn2g -Xss128k pacakage.HelloWorld

##### 垃圾收集器设置

> -XX:+UseSerialGC:设置串行收集器，年轻带收集器， 次收集器
> -XX:+UseParallelGC:设置并行收集器
> -XX:+UseParNewGC:设置年轻代为并行收集。可与 CMS 收集同时使用。JDK5.0 以上，JVM
> 会根据系统配置自行设置，所以无需再设置此值。
> -XX:+UseParallelOldGC:设置并行年老代收集器，JDK6.0 支持对年老代并行收集。
> -XX:+UseConcMarkSweepGC:设置年老代并发收集器，测试中配置这个以后，-XX:NewRatio
> 的配置失效，原因不明。所以，此时年轻代大小最好用-Xmn 设置。
> -XX:+UseG1GC:设置 G1 收集器

##### 垃圾回收统计信息（日志打印）

> -XX:+PrintGC
> -XX:+Printetails
> -XX:+PrintGCTimeStamps
> -Xloggc:filename

##### 自定义参数

> -D 后面接自定义参数

##### 参数设置经验相关

###### 内存设置经验

一般整体使用80%内存空间，适合高并发本地测试

> -Xmx3550m  
>
> -Xms3550m 
>
> -Xss128k 
>
>  -XX:NewRatio=4 
>
>  -XX:SurvicorRatio=4
>
> -XX:MaxPermSize=160m 
>
> -XX:MaxTenuringThreshold=0

假设环境：16G物理内存 高并发服务，重量级对象中等（线程池，连接池等），常用对象40%（运行过程产生对象有40%生命周期较长）

> -Xmx10G  
>
> -Xms10G 
>
> -Xss1M 
>
>  -XX:NewRatio=3 
>
>  -XX:SurvicorRatio=4
>
> -XX:MaxPermSize=2048m 
>
> -XX:MaxTenuringThreshold=5
>
> | 生命周期较长对象占比 | MaxTenuringThreshold值 |
> | -------------------- | ---------------------- |
> | 5%                   | 15                     |
> | 10%                  | 12-15                  |
> | 20%                  | 8-11                   |
> | 30%                  | 6-8                    |
> | 40%                  | 5-8                    |





###### 并行垃圾收集器

并行收集器一般用于科学计算

> Xmx3800m -Xms3800m -Xmn2g -Xss128k 
>
> -XX:+UseParallelGC  使用 ParallelGC 作为并行收集器
>
> -XX:ParallelGCThreads=20 GC 线程为 20（CPU 核心数>=20 时）
>
> -XX:+UseParallelOldGC 指定老年代收集器
>
> -XX:MaxGCPauseMillis=100 指定 GC 时最大暂停时间
>
> -XX:+UseAdaptiveSizePolicy 动态分配，提高年轻代GC效率

###### 并发收集器

  	保证系统响应时间，减少垃圾收集停顿时间，适用于应用门户服务器、电信、互联网。

​	 并发GC的线程建议使用（CPU 核心数+3）/4，25%左右资源给GC线程

> -Xmx3550m -Xms3550m -Xmn2g -Xss128k 
>
> -XX:ParallelGCThreads=20 GC 线程为 20（CPU 核心数>=20 时）
>
> -XX:+UseConcMarkSweepGC 
>
> -XX:+UseParNewGC

CMS收集器

> -Xmx3550m -Xms3550m -Xmn2g -Xss128k
>
>  -XX:+UseConcMarkSweepGC
>
> -XX:CMSFullGCsBeforeCompaction=5 
>
> -XX:+UseCMSCompactAtFullCollection